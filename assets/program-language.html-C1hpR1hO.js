import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,b as t,d as n,e as a,a as s,r as i,o as p}from"./app-CRXmQLa0.js";const d={},c={id:"python-gli锁",tabindex:"-1"},h={class:"header-anchor",href:"#python-gli锁"},m={id:"python-async",tabindex:"-1"},y={class:"header-anchor",href:"#python-async"};function u(g,e){const o=i("Badge");return p(),r("div",null,[e[2]||(e[2]=t("h1",{id:"编程语言基础",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#编程语言基础"},[t("span",null,"编程语言基础")])],-1)),t("h2",c,[t("a",h,[t("span",null,[e[0]||(e[0]=n("Python GLI锁 ",-1)),a(o,{text:"掌握",type:"tip"})])])]),e[3]||(e[3]=t("ul",null,[t("li",null,[t("p",null,[n("GIL 是 CPython 解释器的一把互斥锁，"),t("strong",null,"同一时刻仅允许一个线程执行 Python 字节码"),n("，即使在多核 CPU 上，Python 多线程也无法实现真正的并行（仅能并发）。")])]),t("li",null,[t("p",null,"为什么 Python 保留 GIL？"),t("p",null,"简化 CPython 的内存管理（避免多线程内存竞争）；")]),t("li",null,[t("p",null,[n("GIL 的影响？"),t("br"),n(" ① 多线程在 CPU 密集型任务中无性能提升（甚至因线程切换开销变慢）；② 多线程在 IO 密集型任务（如网络请求、文件读写）中仍有效（线程等待 IO 时释放 GIL）；③ 多进程可绕过 GIL（每个进程有独立解释器和 GIL）。")])])],-1)),t("h2",m,[t("a",y,[t("span",null,[e[1]||(e[1]=n("Python async ",-1)),a(o,{text:"掌握",type:"tip"})])])]),e[4]||(e[4]=s("<p><strong>核心定义</strong></p><ul><li><code>async def</code>：定义异步函数（协程），函数执行时不会阻塞主线程；</li><li><code>await</code>：挂起协程执行，等待异步任务（如 IO）完成，此时事件循环可调度其他协程；</li><li>事件循环（Event Loop）：asyncio 的核心，负责调度协程、管理 IO 事件，是 “单线程并发” 的核心。</li><li>协程最大的优势在于用单个线程模拟多个线程并发</li></ul><p><strong>使用场景</strong></p><ul><li><p>耗时的IO操作：网络请求、文件读写、数据库查询（这些操作通常需要等待响应，导致程序阻塞），使用asyncio可以在等待时执行其他任务</p></li><li><p>async vs 多线程？</p><p>① 相同点：均适用于 IO 密集型；② 不同点：async 是 “用户态协程”，切换开销远小于线程（内核态），高并发下（如 10w + 请求）性能更优；③ 注意：async 需配套异步库（如 aiohttp 而非 requests）。</p></li></ul>",4))])}const L=l(d,[["render",u]]),G=JSON.parse('{"path":"/docs/fundamentals/program-language.html","title":"编程语言基础","lang":"zh-CN","frontmatter":{"description":"编程语言基础 Python GLI锁 GIL 是 CPython 解释器的一把互斥锁，同一时刻仅允许一个线程执行 Python 字节码，即使在多核 CPU 上，Python 多线程也无法实现真正的并行（仅能并发）。 为什么 Python 保留 GIL？ 简化 CPython 的内存管理（避免多线程内存竞争）； GIL 的影响？ ① 多线程在 CPU 密...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"编程语言基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-01-30T14:31:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LLMPedia\\",\\"url\\":\\"https://llmpedia.online\\"}]}"],["meta",{"property":"og:url","content":"https://llmpedia.online/docs/fundamentals/program-language.html"}],["meta",{"property":"og:site_name","content":"LLMPedia"}],["meta",{"property":"og:title","content":"编程语言基础"}],["meta",{"property":"og:description","content":"编程语言基础 Python GLI锁 GIL 是 CPython 解释器的一把互斥锁，同一时刻仅允许一个线程执行 Python 字节码，即使在多核 CPU 上，Python 多线程也无法实现真正的并行（仅能并发）。 为什么 Python 保留 GIL？ 简化 CPython 的内存管理（避免多线程内存竞争）； GIL 的影响？ ① 多线程在 CPU 密..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-30T14:31:16.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-30T14:31:16.000Z"}]]},"git":{"createdTime":1769783476000,"updatedTime":1769783476000,"contributors":[{"name":"Marshall-Ge","username":"Marshall-Ge","email":"1004083966@qq.com","commits":1,"url":"https://github.com/Marshall-Ge"}]},"readingTime":{"minutes":1.38,"words":413},"filePathRelative":"docs/fundamentals/program-language.md","autoDesc":true}');export{L as comp,G as data};
